import heapq
from itertools import count

start = {'A': [3, 2, 1], 'B': [], 'C': []}
goal = {'A': [], 'B': [], 'C': [3, 2, 1]}

# tie-breaker counter to avoid comparing dicts
counter = count()

def clone(state):
    return {k: v[:] for k, v in state.items()}

def get_state_tuple(state):
    return (tuple(state['A']), tuple(state['B']), tuple(state['C']))

def heuristic(state):
    # disks NOT on final peg C
    return len(state['A']) + len(state['B'])

def a_star_hanoi():
    pq = []
    heapq.heappush(pq, (0, next(counter), start, []))
    visited = set()

    while pq:
        cost, _, state, path = heapq.heappop(pq)
        t = get_state_tuple(state)

        if t in visited:
            continue
        visited.add(t)

        if t == get_state_tuple(goal):
            return path

        for s in "ABC":
            if not state[s]:
                continue

            disk = state[s][-1]

            for d in "ABC":
                if s == d:
                    continue

                if not state[d] or state[d][-1] > disk:
                    new_state = clone(state)
                    new_state[s].pop()
                    new_state[d].append(disk)

                    g = len(path) + 1
                    h = heuristic(new_state)
                    f = g + h

                    heapq.heappush(
                        pq, (f, next(counter), new_state,
                             path + [f"Move Disk {disk} from {s} â†’ {d}"])
                    )

solution = a_star_hanoi()

print("A* Solution:")
for i, step in enumerate(solution, 1):
    print(f"{i}. {step}")
